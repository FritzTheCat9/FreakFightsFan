@using System.Linq.Expressions
@typeparam T

@if (HasErrorsForProperty(For))
{
    <div class="mud-input-control-helper-container">
        @foreach (var error in GetErrorsForProperty(For))
        {
            <p class="mud-input-helper-text mud-input-error">
                <div class="d-flex">
                    <div class="me-auto">@error</div>
                </div>
            </p>
        }
    </div>
}

@code {
    [Parameter] public Expression<Func<T>> For { get; set; }
    [Parameter] public ValidationErrors ValidationErrors { get; set; }

    private bool HasErrorsForProperty(Expression<Func<T>> expression)
    {
        var propertyName = GetPropertyName(expression);
        return ValidationErrors.Errors.ContainsKey(propertyName) && ValidationErrors.Errors[propertyName].Any();
    }

    private List<string> GetErrorsForProperty(Expression<Func<T>> expression)
    {
        var propertyName = GetPropertyName(expression);
        return ValidationErrors.Errors[propertyName];
    }

    private string GetPropertyName(Expression<Func<T>> expression)
    {
        if (expression.Body is MemberExpression memberExpression)
        {
            return memberExpression.Member.Name;
        }

        throw new ArgumentException("Invalid expression");      // TODO: handle component exceptions
    }
}
